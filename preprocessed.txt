gcc -c -E build/parser.o src/parser.c -I -Wall -Wextra -Wshadow -Wundef -Wformat=2 -Wfloat-equal -Wcast-align -std=c17 -march=native -O3 -Ofast -g -lm
# 1 "src/parser.c"
# 1 "/home/alice/GIT/Pascal-Minus-Minus-Compiler//"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "<command-line>" 2
# 1 "src/parser.c"





# 1 "src/../header/parser.h" 1







# 1 "src/../header/../header/lexer.h" 1







# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdbool.h" 1 3 4
# 9 "src/../header/../header/lexer.h" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4
# 84 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 173 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __attribute__ ((__warn_unused_result__));
# 187 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 213 "/usr/include/stdio.h" 3 4
extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) __attribute__ ((__warn_unused_result__));




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 304 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
# 326 "/usr/include/stdio.h" 3 4
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 391 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                          __attribute__ ((__warn_unused_result__));
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                         __attribute__ ((__warn_unused_result__));
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 564 "/usr/include/stdio.h" 3 4
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__));
# 626 "/usr/include/stdio.h" 3 4
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 684 "/usr/include/stdio.h" 3 4
extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 757 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 775 "/usr/include/stdio.h" 3 4
extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 782 "/usr/include/stdio.h" 2 3 4
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}
# 81 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}
# 865 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      const char *__restrict __format,
      __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) sprintf (char *__restrict __s, const char *__restrict __fmt, ...)
{
  return __builtin___sprintf_chk (__s, 2 - 1,
      __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsprintf (char *__restrict __s, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsprintf_chk (__s, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, const char *__restrict __format,
      ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, const char *__restrict __format,
       __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) snprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, ...)

{
  return __builtin___snprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsnprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}





extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
     const char *__restrict __format, ...);
extern int __printf_chk (int __flag, const char *__restrict __format, ...);
extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
      const char *__restrict __format, __gnuc_va_list __ap);
extern int __vprintf_chk (int __flag, const char *__restrict __format,
     __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __ap)
{

  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);



}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vfprintf (FILE *__restrict __stream,
   const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
}
# 243 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")

                                        __attribute__ ((__warn_unused_result__));
extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")


            __attribute__ ((__warn_unused_result__));
extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}
# 868 "/usr/include/stdio.h" 2 3 4






# 10 "src/../header/../header/lexer.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4


# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 199 "/usr/include/stdlib.h" 3 4
__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ , __leaf__)) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}
# 453 "/usr/include/stdlib.h" 3 4
extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));
# 539 "/usr/include/stdlib.h" 3 4
extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) __attribute__ ((__warn_unused_result__));






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));
# 565 "/usr/include/stdlib.h" 3 4
extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));
# 586 "/usr/include/stdlib.h" 3 4
extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) __attribute__ ((__warn_unused_result__));



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 617 "/usr/include/stdlib.h" 3 4
extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) __attribute__ ((__warn_unused_result__));
# 808 "/usr/include/stdlib.h" 3 4
typedef int (*__compar_fn_t) (const void *, const void *);
# 820 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return ((void *)0);
}
# 826 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 840 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
# 922 "/usr/include/stdlib.h" 3 4
extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ , __leaf__)) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
# 1014 "/usr/include/stdlib.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 3 4
extern char *__realpath_chk (const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (const char *__restrict __name, char *__restrict __resolved) __asm__ ("" "realpath") __attribute__ ((__nothrow__ , __leaf__))

                                                 __attribute__ ((__warn_unused_result__));
extern char *__realpath_chk_warn (const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) __asm__ ("" "__realpath_chk") __attribute__ ((__nothrow__ , __leaf__))


                                                __attribute__ ((__warn_unused_result__))
     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")))
                                      ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) realpath (const char *__restrict __name, char *__restrict __resolved)
{
  if (__builtin_object_size (__resolved, 2 > 1) != (size_t) -1)
    {




      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 2 > 1));
    }

  return __realpath_alias (__name, __resolved);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ptsname_r") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ptsname_r_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")))
                   ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ptsname_r (int __fd, char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("" "wctomb") __attribute__ ((__nothrow__ , __leaf__))
              __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) int
__attribute__ ((__nothrow__ , __leaf__)) wctomb (char *__s, wchar_t __wchar)
{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         const char *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len) __asm__ ("" "mbstowcs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__mbstowcs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbstowcs (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbstowcs_chk (__dst, __src, __len,
          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbstowcs_chk_warn (__dst, __src, __len,
         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __wcstombs_alias (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len) __asm__ ("" "wcstombs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __wcstombs_chk_warn (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__wcstombs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcstombs (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
    }
  return __wcstombs_alias (__dst, __src, __len);
}
# 1018 "/usr/include/stdlib.h" 2 3 4






# 11 "src/../header/../header/lexer.h" 2

# 1 "src/../header/../header/../header/string.h" 1








# 8 "src/../header/../header/../header/string.h"
typedef struct {
    char* str;
    unsigned long size;
    unsigned long capacity;
} String;

void stringInit(String* s);
void stringDestroy(String* s);

void stringAppendChar(String* s, char c);
void stringAppendCstr(String* s, const char* cstr);
void stringAppendInt(String* s, int integer);

void stringOverwrite(String* s, const char cstr[], unsigned long size);

void _stringExpand(String* s, unsigned long newCapacity);
# 13 "src/../header/../header/lexer.h" 2
# 26 "src/../header/../header/lexer.h"
enum TOKEN_CLASS { LAMBDA, N_REAL, N_INTEGER, OP_UN, OP_ADD, OP_MULT, RELATION,
                    ASSIGN, DECLARE_TYPE, SEMICOLON, COLON,
                    OPEN_PAR, CLOSE_PAR, DOT, ID, BEGIN, CONST,
                    DO, END, ELSE, IF, INTEGER, FOR, PROGRAM, PROCEDURE,
                    REAL, READ, THEN, TO, VAR, WRITE, WHILE, ERROR};


typedef struct {
    String buffer;
    FILE* sourceCode;
    FILE* tokenOutput;
    int tokenClass;

    int transitionMatrix[32][128];
    
# 40 "src/../header/../header/lexer.h" 3 4
   _Bool 
# 40 "src/../header/../header/lexer.h"
        finalState[32];
    char finalStateClass[32];


    int protectedSymbolMatrix[65][26];

    char protectedSymbolFinalStates[65];

    char currChar;
    int fscanfFlag;
    int currState;
    int currLine;
    int currCol;

    
# 54 "src/../header/../header/lexer.h" 3 4
   _Bool 
# 54 "src/../header/../header/lexer.h"
        lastWasNumberOrIdent;
} Lexer;


# 57 "src/../header/../header/lexer.h" 3 4
_Bool 
# 57 "src/../header/../header/lexer.h"
    lexerInit(Lexer* lexer, const char* sourceFilePath);
void lexerDestroy(Lexer* lexer);
int nextToken(Lexer* lexer, FILE* output);

int lexerCurrColWithoutRetreat(Lexer* lexer);
const char* lexerErrorMessage(int currState);
const char* lexerTokenClassName(int token_class);
char* lexerBuffer(Lexer* lexer);


void _buildTransitionMatrix(int transitionMatrix[32][128]);
void _buildFinalStates(
# 68 "src/../header/../header/lexer.h" 3 4
                      _Bool 
# 68 "src/../header/../header/lexer.h"
                           finalState[32], char finalStateClass[32]);
void _buildProtectedSymbolMatrix(int protectedSymbolMatrix[65][26]);
void _buildProtectedSymbolFinalStates(char protectedSymbolFinalState[65]);


void _fillOther(int transitionMatrix[32][128], int startState, int endState);
void _fillWord(int protectedSymbolMatrix[65][26], const char word[], int firstState, int secondState);


void _nextChar(Lexer* lexer);
void _dealWithEOF(Lexer* lexer);
void _nextState(Lexer* lexer);
void _identifyTokenClass(Lexer* lexer);
int _checkIfProtectedSymbol(Lexer* lexer);
# 9 "src/../header/parser.h" 2


typedef struct {
    Lexer lexer;
    FILE* output;

    int errorCount;
} Parser;


# 18 "src/../header/parser.h" 3 4
_Bool 
# 18 "src/../header/parser.h"
    parserInit(Parser* parser, const char* sourceCodePath);
void parserDestroy(Parser* parser);
void compile(Parser* parser);

void _error(Parser* parser, int expectedTokenClass, int sincTokens[]);


void _sincTokensInit(int sincTokens[]);
void _sincTokensCopy(int sincTokens[], int copySincTokens[]);
void _sincTokensIncr(int sincTokens[]);
void _sincTokensAdd(int sincTokens[], const int toAdd[], unsigned long toAddSize);


void _programa(Parser* parser, int sincTokens[]);
void _corpo(Parser* parser, int sincTokens[]);
void _dc(Parser* parser, int sincTokens[]);
void _dc_c(Parser* parser, int sincTokens[]);
void _dc_v(Parser* parser, int sincTokens[]);
void _tipo_var(Parser* parser, int sincTokens[]);
void _variaveis(Parser* parser, int sincTokens[]);
void _mais_var(Parser* parser, int sincTokens[]);
void _dc_p(Parser* parser, int sincTokens[]);
void _parametros(Parser* parser, int sincTokens[]);
void _lista_par(Parser* parser, int sincTokens[]);
void _mais_par(Parser* parser, int sincTokens[]);
void _corpo_p(Parser* parser, int sincTokens[]);
void _dc_loc(Parser* parser, int sincTokens[]);
void _lista_arg(Parser* parser, int sincTokens[]);
void _argumentos(Parser* parser, int sincTokens[]);
void _mais_ident(Parser* parser, int sincTokens[]);
void _pfalsa(Parser* parser, int sincTokens[]);
void _comandos(Parser* parser, int sincTokens[]);
void _cmd(Parser* parser, int sincTokens[]);
void _pos_ident(Parser* parser, int sincTokens[]);
void _condicao(Parser* parser, int sincTokens[]);
void _relacao(Parser* parser, int sincTokens[]);
void _expressao(Parser* parser, int sincTokens[]);
void _op_un(Parser* parser, int sincTokens[]);
void _outros_termos(Parser* parser, int sincTokens[]);
void _op_ad(Parser* parser, int sincTokens[]);
void _termo(Parser* parser, int sincTokens[]);
void _mais_fatores(Parser* parser, int sincTokens[]);
void _op_mul(Parser* parser, int sincTokens[]);
void _fator(Parser* parser, int sincTokens[]);
void _numero(Parser* parser, int sincTokens[]);
# 7 "src/parser.c" 2




# 1 "src/../header/string.h" 1
# 12 "src/parser.c" 2
# 66 "src/parser.c"

# 66 "src/parser.c" 3 4
_Bool 
# 66 "src/parser.c"
    parserInit(Parser* parser, const char* sourceCodePath) {
    parser->errorCount = 0;

    if (lexerInit(&parser->lexer, sourceCodePath)) {
        return 
# 70 "src/parser.c" 3 4
              1
# 70 "src/parser.c"
                  ;
    }


    parser->output = fopen("output.txt", "w");
    if (parser->output == 
# 75 "src/parser.c" 3 4
                         ((void *)0)
# 75 "src/parser.c"
                             ) {
        printf("Error: couldn't create output file\n");
        return 
# 77 "src/parser.c" 3 4
              1
# 77 "src/parser.c"
                  ;
    }

    return 
# 80 "src/parser.c" 3 4
          0
# 80 "src/parser.c"
               ;
}






void parserDestroy(Parser* parser) {
    fclose(parser->output);
    lexerDestroy(&parser->lexer);
}
# 101 "src/parser.c"
void _sincTokensInit(int sincTokens[]) {
    for (int i = 0; i < 32; i++) {
        sincTokens[i] = -1;
    }
}







void _sincTokensCopy(int sincTokens[], int copySincTokens[]) {
    for (int i = 0; i < 32; i++) {
        copySincTokens[i] += sincTokens[i];
    }
}






void _sincTokensIncr(int sincTokens[]) {
    for (int i = 0; i < 32; i++) {
        sincTokens[i] += (sincTokens[i] >= 0);
    }
}






void _sincTokensAdd(int sincTokens[], const int toAdd[], unsigned long toAddSize) {
    for (unsigned long i = 0; i < toAddSize; i++) {
        sincTokens[toAdd[i]] = 0;
    }
}






void _sincTokensRemove(int sincTokens[], const int toRemove[], unsigned long toRemoveSize) {
    for (unsigned long i = 0; i < toRemoveSize; i++) {
        sincTokens[toRemove[i]] = -1;
    }
}






void compile(Parser* parser) {

    parser->errorCount += nextToken(&parser->lexer, parser->output);


    int sincTokens[32];
    _sincTokensInit(sincTokens);


    const int followers[] = {LAMBDA};
    _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int));
    _programa(parser, sincTokens);


    if (parser->lexer.fscanfFlag != 
# 171 "src/parser.c" 3 4
                                   (-1)
# 171 "src/parser.c"
                                      ) {
        _error(parser, 
# 172 "src/parser.c" 3 4
                      (-1)
# 172 "src/parser.c"
                         , sincTokens);
    }
}






void _programa(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == PROGRAM) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {ID}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, PROGRAM, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
    if (parser->lexer.tokenClass == ID) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {SEMICOLON}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, ID, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
    if (parser->lexer.tokenClass == SEMICOLON) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {CONST, VAR, PROCEDURE, BEGIN}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, SEMICOLON, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }

    static const int followers[] = {DOT}; _sincTokensAdd(sincTokens, followers, sizeof(followers)/sizeof(int)); _corpo(parser, sincTokens); static const int followers[] = {DOT}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;

    if (parser->lexer.tokenClass == DOT) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {LAMBDA}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, DOT, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
}







void _corpo(Parser* parser, int sincTokens[]) {

    static const int followers[] = {BEGIN}; _sincTokensAdd(sincTokens, followers, sizeof(followers)/sizeof(int)); _dc(parser, sincTokens); static const int followers[] = {BEGIN}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;

    if (parser->lexer.tokenClass == BEGIN) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {READ, WRITE, WHILE, IF, FOR, ID, BEGIN, END}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, BEGIN, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }

    static const int followers[] = {END}; _sincTokensAdd(sincTokens, followers, sizeof(followers)/sizeof(int)); _comandos(parser, sincTokens); static const int followers[] = {END}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;

    if (parser->lexer.tokenClass == END) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {DOT}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, END, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
}






void _dc(Parser* parser, int sincTokens[]) {

    static const int followers[] = {BEGIN, VAR, PROCEDURE}; _sincTokensAdd(sincTokens, followers, sizeof(followers)/sizeof(int)); _dc_c(parser, sincTokens); static const int followers[] = {BEGIN, VAR, PROCEDURE}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    static const int followers[] = {BEGIN, PROCEDURE}; _sincTokensAdd(sincTokens, followers, sizeof(followers)/sizeof(int)); _dc_v(parser, sincTokens); static const int followers[] = {BEGIN, PROCEDURE}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    static const int followers[] = {BEGIN}; _sincTokensAdd(sincTokens, followers, sizeof(followers)/sizeof(int)); _dc_p(parser, sincTokens); static const int followers[] = {BEGIN}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;

}






void _dc_c(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == CONST) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        return;
    }
    if (parser->lexer.tokenClass == ID) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {ASSIGN}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, ID, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
    if (parser->lexer.tokenClass == ASSIGN) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {N_INTEGER, N_REAL}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, ASSIGN, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }

    NEXT_RULE(_numero, SEMICOLON)

    if (parser->lexer.tokenClass == SEMICOLON) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {CONST, BEGIN, VAR, PROCEDURE}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, SEMICOLON, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; };
    }

    NEXT_RULE(_dc_c, BEGIN, VAR, PROCEDURE)
}






void _dc_v(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == VAR) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        return;
    }

    NEXT_RULE(_variaveis, DECLARE_TYPE)

    if (parser->lexer.tokenClass == DECLARE_TYPE) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {REAL, INTEGER}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, DECLARE_TYPE, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }

    NEXT_RULE(_tipo_var, SEMICOLON)

    if (parser->lexer.tokenClass == SEMICOLON) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {VAR, BEGIN, PROCEDURE}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, SEMICOLON, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }

    NEXT_RULE(_dc_v, BEGIN, PROCEDURE)
}






void _tipo_var(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == REAL || parser->lexer.tokenClass == INTEGER) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {


        static const int followers[] = {SEMICOLON, CLOSE_PAR}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, REAL, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
}






void _variaveis(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == ID) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {COLON, DECLARE_TYPE, CLOSE_PAR}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, ID, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }

    NEXT_RULE(_mais_var, DECLARE_TYPE, CLOSE_PAR)
}






void _mais_var(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == COLON) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        return;
    }

    NEXT_RULE(_variaveis, DECLARE_TYPE, CLOSE_PAR)
}






void _dc_p(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == PROCEDURE) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        return;
    }
    if (parser->lexer.tokenClass == ID) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {OPEN_PAR, SEMICOLON}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, ID, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }

    NEXT_RULE(_parametros, SEMICOLON)

    if (parser->lexer.tokenClass == SEMICOLON) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {VAR, BEGIN}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, SEMICOLON, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }

    NEXT_RULE(_corpo_p, BEGIN, PROCEDURE)
    NEXT_RULE(_dc_p, BEGIN)
}






void _parametros(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == OPEN_PAR) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        return;
    }

    NEXT_RULE(_lista_par, CLOSE_PAR)

    if (parser->lexer.tokenClass == CLOSE_PAR) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {SEMICOLON}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, CLOSE_PAR, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
}






void _lista_par(Parser* parser, int sincTokens[]) {

    NEXT_RULE(_variaveis, DECLARE_TYPE)

    if (parser->lexer.tokenClass == DECLARE_TYPE) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {REAL, INTEGER}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, DECLARE_TYPE, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
    _tipo_var(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    _mais_par(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
}






void _mais_par(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == SEMICOLON) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        return;
    }
    _lista_par(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
}






void _corpo_p(Parser* parser, int sincTokens[]) {
    _dc_loc(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    if (parser->lexer.tokenClass == BEGIN) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {READ, WRITE, WHILE, IF, FOR, ID, BEGIN, END}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, BEGIN, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
    _comandos(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    if (parser->lexer.tokenClass == END) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {SEMICOLON}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, END, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
    if (parser->lexer.tokenClass == SEMICOLON) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {BEGIN, PROCEDURE}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, SEMICOLON, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
}






void _dc_loc(Parser* parser, int sincTokens[]) {
    _dc_v(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
}






void _lista_arg(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == OPEN_PAR) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        return;
    }
    _argumentos(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    if (parser->lexer.tokenClass == CLOSE_PAR) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {SEMICOLON}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, CLOSE_PAR, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
}






void _argumentos(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == ID) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {SEMICOLON, CLOSE_PAR}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, ID, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
    _mais_ident(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
}






void _mais_ident(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == SEMICOLON) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    }
    _argumentos(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
}






void _pfalsa(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == ELSE) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        return;
    }
    _cmd(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
}






void _comandos(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass != READ &&
        parser->lexer.tokenClass != WRITE &&
        parser->lexer.tokenClass != WHILE &&
        parser->lexer.tokenClass != IF &&
        parser->lexer.tokenClass != FOR &&
        parser->lexer.tokenClass != ID &&
        parser->lexer.tokenClass != BEGIN) {
        return;
    }
    _cmd(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    if (parser->lexer.tokenClass == SEMICOLON) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {READ, WRITE, WHILE, IF, FOR, ID, BEGIN, END}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, SEMICOLON, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
    _comandos(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
}
# 576 "src/parser.c"
void _cmd(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == READ) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
        if (parser->lexer.tokenClass == OPEN_PAR) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {ID}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, OPEN_PAR, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
        _variaveis(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        if (parser->lexer.tokenClass == CLOSE_PAR) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {END}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, CLOSE_PAR, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
    } else if (parser->lexer.tokenClass == WRITE) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
        if (parser->lexer.tokenClass == OPEN_PAR) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {ID}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, OPEN_PAR, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
        _variaveis(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        if (parser->lexer.tokenClass == CLOSE_PAR) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {END}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, CLOSE_PAR, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
    } else if (parser->lexer.tokenClass == WHILE) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
        if (parser->lexer.tokenClass == OPEN_PAR) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {OP_UN, ID, OPEN_PAR, N_INTEGER, N_REAL}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, OPEN_PAR, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
        _condicao(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        if (parser->lexer.tokenClass == CLOSE_PAR) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {DO}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, CLOSE_PAR, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
        if (parser->lexer.tokenClass == DO) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {READ, WRITE, WHILE, IF, FOR, ID, BEGIN}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, DO, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
        _cmd(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    } else if (parser->lexer.tokenClass == IF) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
        _condicao(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        if (parser->lexer.tokenClass == THEN) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {READ, WRITE, WHILE, IF, FOR, ID, BEGIN}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, THEN, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
        _cmd(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        _pfalsa(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    } else if (parser->lexer.tokenClass == FOR) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
        if (parser->lexer.tokenClass == ID) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {ASSIGN}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, ID, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
        if (parser->lexer.tokenClass == ASSIGN) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {OP_UN, ID, OPEN_PAR, N_INTEGER, N_REAL}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, ASSIGN, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
        _expressao(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        if (parser->lexer.tokenClass == TO) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {OP_UN, ID, OPEN_PAR, N_INTEGER, N_REAL}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, TO, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
        _expressao(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        if (parser->lexer.tokenClass == DO) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {READ, WRITE, WHILE, IF, FOR, ID, BEGIN}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, DO, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
        _cmd(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    } else if (parser->lexer.tokenClass == ID) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
        _pos_ident(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    } else if (parser->lexer.tokenClass == BEGIN) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
        _comandos(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        if (parser->lexer.tokenClass == END) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {SEMICOLON}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, END, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
    } else {
        static const int followers[] = {SEMICOLON}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, SEMICOLON, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
}






void _pos_ident(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == ASSIGN) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
        _expressao(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    } else {
        _lista_arg(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    }
}






void _condicao(Parser* parser, int sincTokens[]) {
    _expressao(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    _relacao(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    _expressao(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
}






void _relacao(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == RELATION) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {OP_UN, ID, OPEN_PAR, N_INTEGER, N_REAL}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, RELATION, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
}






void _expressao(Parser* parser, int sincTokens[]) {
    _termo(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    _outros_termos(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
}






void _op_un(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == OP_UN) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    }
}






void _outros_termos(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == OP_ADD) {
        _op_ad(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        _termo(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        _outros_termos(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    }
}






void _op_ad(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == OP_ADD) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {OP_UN, ID, OPEN_PAR, N_INTEGER, N_REAL}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, OP_ADD, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
}






void _termo(Parser* parser, int sincTokens[]) {
    _op_un(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    _fator(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    _mais_fatores(parser);
    static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
}






void _mais_fatores(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == OP_MULT) {
        _op_mul(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        _fator(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        _mais_fatores(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    }
}






void _op_mul(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == OP_MULT) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        static const int followers[] = {ID, OPEN_PAR, N_INTEGER, N_REAL}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, OP_MULT, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
    }
}






void _fator(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == ID) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else if (parser->lexer.tokenClass == OPEN_PAR) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
        _expressao(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
        if (parser->lexer.tokenClass == CLOSE_PAR) {
            parser->errorCount += nextToken(&parser->lexer, parser->output);
        } else {
            static const int followers[] = {OP_MULT}; _sincTokensAdd(sincTokens, followers, sizeof(followers) / sizeof(int)); _error(parser, CLOSE_PAR, sincTokens); int level = sincTokens[parser->lexer.tokenClass]--; _sincTokensRemove(sincTokens, followers, sizeof(followers) / sizeof(int)); if (level != 0) { return; }
        }
    } else {
        _numero(parser);
        static const int followers[] = {}; int return_flag = 0; if (sincTokens[parser->lexer.tokenClass] >= 0) { sincTokens[parser->lexer.tokenClass]--; if (sincTokens[parser->lexer.tokenClass] >= 0) return_flag = 1; } _sincTokensRemove(sincTokens, followers, sizeof(followers)/sizeof(int)); if(return_flag) return;
    }
}






void _numero(Parser* parser, int sincTokens[]) {
    if (parser->lexer.tokenClass == N_INTEGER || parser->lexer.tokenClass == N_REAL) {
        parser->errorCount += nextToken(&parser->lexer, parser->output);
    } else {
        parser->errorCount++;
        printf("Parser error on line %d col %d: expected N_INTEGER or N_REAL but found %s\n", parser->lexer.currLine, lexerCurrColWithoutRetreat(&parser->lexer), lexerBuffer(&parser->lexer));
    }
}







void _error(Parser* parser, int expectedTokenClass, int sincTokens[]) {
    parser->errorCount++;

    String errorMsg;
    stringInit(&errorMsg);
    stringAppendCstr(&errorMsg, "Parser error on line ");
    stringAppendInt(&errorMsg, parser->lexer.currLine);
    stringAppendCstr(&errorMsg, " col ");
    stringAppendInt(&errorMsg, lexerCurrColWithoutRetreat(&parser->lexer));
    stringAppendCstr(&errorMsg, ": expected ");
    stringAppendCstr(&errorMsg, lexerTokenClassName(expectedTokenClass));
    stringAppendCstr(&errorMsg, " but found ");
    stringAppendCstr(&errorMsg, lexerBuffer(&parser->lexer));
    stringAppendChar(&errorMsg, '\n');
    printf("%s", errorMsg.str);
    fprintf(parser->output, "%s", errorMsg.str);

    stringDestroy(&errorMsg);

    while (sincTokens[parser->lexer.tokenClass] == -1)
        parser->errorCount += nextToken(&parser->lexer, parser->output);
}
gcc -c -E build/main.o src/main.c -I -Wall -Wextra -Wshadow -Wundef -Wformat=2 -Wfloat-equal -Wcast-align -std=c17 -march=native -O3 -Ofast -g -lm
# 1 "src/main.c"
# 1 "/home/alice/GIT/Pascal-Minus-Minus-Compiler//"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "<command-line>" 2
# 1 "src/main.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4
# 84 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 173 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __attribute__ ((__warn_unused_result__));
# 187 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 213 "/usr/include/stdio.h" 3 4
extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) __attribute__ ((__warn_unused_result__));




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 304 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));
# 326 "/usr/include/stdio.h" 3 4
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 391 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                          __attribute__ ((__warn_unused_result__));
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                         __attribute__ ((__warn_unused_result__));
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 564 "/usr/include/stdio.h" 3 4
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__));
# 626 "/usr/include/stdio.h" 3 4
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 684 "/usr/include/stdio.h" 3 4
extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 757 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 775 "/usr/include/stdio.h" 3 4
extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 782 "/usr/include/stdio.h" 2 3 4
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}
# 81 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}
# 865 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      const char *__restrict __format,
      __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) sprintf (char *__restrict __s, const char *__restrict __fmt, ...)
{
  return __builtin___sprintf_chk (__s, 2 - 1,
      __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsprintf (char *__restrict __s, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsprintf_chk (__s, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, const char *__restrict __format,
      ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, const char *__restrict __format,
       __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) snprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, ...)

{
  return __builtin___snprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsnprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}





extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
     const char *__restrict __format, ...);
extern int __printf_chk (int __flag, const char *__restrict __format, ...);
extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
      const char *__restrict __format, __gnuc_va_list __ap);
extern int __vprintf_chk (int __flag, const char *__restrict __format,
     __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __ap)
{

  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);



}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vfprintf (FILE *__restrict __stream,
   const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
}
# 243 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")

                                        __attribute__ ((__warn_unused_result__));
extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")


            __attribute__ ((__warn_unused_result__));
extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}
# 868 "/usr/include/stdio.h" 2 3 4






# 2 "src/main.c" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4


# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 199 "/usr/include/stdlib.h" 3 4
__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ , __leaf__)) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}
# 453 "/usr/include/stdlib.h" 3 4
extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));
# 539 "/usr/include/stdlib.h" 3 4
extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) __attribute__ ((__warn_unused_result__));






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));
# 565 "/usr/include/stdlib.h" 3 4
extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));
# 586 "/usr/include/stdlib.h" 3 4
extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) __attribute__ ((__warn_unused_result__));



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 617 "/usr/include/stdlib.h" 3 4
extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) __attribute__ ((__warn_unused_result__));
# 808 "/usr/include/stdlib.h" 3 4
typedef int (*__compar_fn_t) (const void *, const void *);
# 820 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return ((void *)0);
}
# 826 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 840 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
# 922 "/usr/include/stdlib.h" 3 4
extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ , __leaf__)) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
# 1014 "/usr/include/stdlib.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 3 4
extern char *__realpath_chk (const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (const char *__restrict __name, char *__restrict __resolved) __asm__ ("" "realpath") __attribute__ ((__nothrow__ , __leaf__))

                                                 __attribute__ ((__warn_unused_result__));
extern char *__realpath_chk_warn (const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) __asm__ ("" "__realpath_chk") __attribute__ ((__nothrow__ , __leaf__))


                                                __attribute__ ((__warn_unused_result__))
     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")))
                                      ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) realpath (const char *__restrict __name, char *__restrict __resolved)
{
  if (__builtin_object_size (__resolved, 2 > 1) != (size_t) -1)
    {




      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 2 > 1));
    }

  return __realpath_alias (__name, __resolved);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ptsname_r") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ptsname_r_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")))
                   ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ptsname_r (int __fd, char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("" "wctomb") __attribute__ ((__nothrow__ , __leaf__))
              __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) int
__attribute__ ((__nothrow__ , __leaf__)) wctomb (char *__s, wchar_t __wchar)
{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         const char *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len) __asm__ ("" "mbstowcs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__mbstowcs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbstowcs (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbstowcs_chk (__dst, __src, __len,
          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbstowcs_chk_warn (__dst, __src, __len,
         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __wcstombs_alias (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len) __asm__ ("" "wcstombs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __wcstombs_chk_warn (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__wcstombs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcstombs (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
    }
  return __wcstombs_alias (__dst, __src, __len);
}
# 1018 "/usr/include/stdlib.h" 2 3 4






# 3 "src/main.c" 2

# 1 "src/../header/parser.h" 1







# 1 "src/../header/../header/lexer.h" 1







# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdbool.h" 1 3 4
# 9 "src/../header/../header/lexer.h" 2



# 1 "src/../header/../header/../header/string.h" 1








# 8 "src/../header/../header/../header/string.h"
typedef struct {
    char* str;
    unsigned long size;
    unsigned long capacity;
} String;

void stringInit(String* s);
void stringDestroy(String* s);

void stringAppendChar(String* s, char c);
void stringAppendCstr(String* s, const char* cstr);
void stringAppendInt(String* s, int integer);

void stringOverwrite(String* s, const char cstr[], unsigned long size);

void _stringExpand(String* s, unsigned long newCapacity);
# 13 "src/../header/../header/lexer.h" 2
# 26 "src/../header/../header/lexer.h"
enum TOKEN_CLASS { LAMBDA, N_REAL, N_INTEGER, OP_UN, OP_ADD, OP_MULT, RELATION,
                    ASSIGN, DECLARE_TYPE, SEMICOLON, COLON,
                    OPEN_PAR, CLOSE_PAR, DOT, ID, BEGIN, CONST,
                    DO, END, ELSE, IF, INTEGER, FOR, PROGRAM, PROCEDURE,
                    REAL, READ, THEN, TO, VAR, WRITE, WHILE, ERROR};


typedef struct {
    String buffer;
    FILE* sourceCode;
    FILE* tokenOutput;
    int tokenClass;

    int transitionMatrix[32][128];
    
# 40 "src/../header/../header/lexer.h" 3 4
   _Bool 
# 40 "src/../header/../header/lexer.h"
        finalState[32];
    char finalStateClass[32];


    int protectedSymbolMatrix[65][26];

    char protectedSymbolFinalStates[65];

    char currChar;
    int fscanfFlag;
    int currState;
    int currLine;
    int currCol;

    
# 54 "src/../header/../header/lexer.h" 3 4
   _Bool 
# 54 "src/../header/../header/lexer.h"
        lastWasNumberOrIdent;
} Lexer;


# 57 "src/../header/../header/lexer.h" 3 4
_Bool 
# 57 "src/../header/../header/lexer.h"
    lexerInit(Lexer* lexer, const char* sourceFilePath);
void lexerDestroy(Lexer* lexer);
int nextToken(Lexer* lexer, FILE* output);

int lexerCurrColWithoutRetreat(Lexer* lexer);
const char* lexerErrorMessage(int currState);
const char* lexerTokenClassName(int token_class);
char* lexerBuffer(Lexer* lexer);


void _buildTransitionMatrix(int transitionMatrix[32][128]);
void _buildFinalStates(
# 68 "src/../header/../header/lexer.h" 3 4
                      _Bool 
# 68 "src/../header/../header/lexer.h"
                           finalState[32], char finalStateClass[32]);
void _buildProtectedSymbolMatrix(int protectedSymbolMatrix[65][26]);
void _buildProtectedSymbolFinalStates(char protectedSymbolFinalState[65]);


void _fillOther(int transitionMatrix[32][128], int startState, int endState);
void _fillWord(int protectedSymbolMatrix[65][26], const char word[], int firstState, int secondState);


void _nextChar(Lexer* lexer);
void _dealWithEOF(Lexer* lexer);
void _nextState(Lexer* lexer);
void _identifyTokenClass(Lexer* lexer);
int _checkIfProtectedSymbol(Lexer* lexer);
# 9 "src/../header/parser.h" 2


typedef struct {
    Lexer lexer;
    FILE* output;

    int errorCount;
} Parser;


# 18 "src/../header/parser.h" 3 4
_Bool 
# 18 "src/../header/parser.h"
    parserInit(Parser* parser, const char* sourceCodePath);
void parserDestroy(Parser* parser);
void compile(Parser* parser);

void _error(Parser* parser, int expectedTokenClass, int sincTokens[]);


void _sincTokensInit(int sincTokens[]);
void _sincTokensCopy(int sincTokens[], int copySincTokens[]);
void _sincTokensIncr(int sincTokens[]);
void _sincTokensAdd(int sincTokens[], const int toAdd[], unsigned long toAddSize);


void _programa(Parser* parser, int sincTokens[]);
void _corpo(Parser* parser, int sincTokens[]);
void _dc(Parser* parser, int sincTokens[]);
void _dc_c(Parser* parser, int sincTokens[]);
void _dc_v(Parser* parser, int sincTokens[]);
void _tipo_var(Parser* parser, int sincTokens[]);
void _variaveis(Parser* parser, int sincTokens[]);
void _mais_var(Parser* parser, int sincTokens[]);
void _dc_p(Parser* parser, int sincTokens[]);
void _parametros(Parser* parser, int sincTokens[]);
void _lista_par(Parser* parser, int sincTokens[]);
void _mais_par(Parser* parser, int sincTokens[]);
void _corpo_p(Parser* parser, int sincTokens[]);
void _dc_loc(Parser* parser, int sincTokens[]);
void _lista_arg(Parser* parser, int sincTokens[]);
void _argumentos(Parser* parser, int sincTokens[]);
void _mais_ident(Parser* parser, int sincTokens[]);
void _pfalsa(Parser* parser, int sincTokens[]);
void _comandos(Parser* parser, int sincTokens[]);
void _cmd(Parser* parser, int sincTokens[]);
void _pos_ident(Parser* parser, int sincTokens[]);
void _condicao(Parser* parser, int sincTokens[]);
void _relacao(Parser* parser, int sincTokens[]);
void _expressao(Parser* parser, int sincTokens[]);
void _op_un(Parser* parser, int sincTokens[]);
void _outros_termos(Parser* parser, int sincTokens[]);
void _op_ad(Parser* parser, int sincTokens[]);
void _termo(Parser* parser, int sincTokens[]);
void _mais_fatores(Parser* parser, int sincTokens[]);
void _op_mul(Parser* parser, int sincTokens[]);
void _fator(Parser* parser, int sincTokens[]);
void _numero(Parser* parser, int sincTokens[]);
# 5 "src/main.c" 2
# 13 "src/main.c"
int main(int argc, char** argv) {

    if (argc != 2) {
        printf("Error: no input files\n");
        return -1;
    }

    Parser parser;
    if (parserInit(&parser, argv[1])) {
        return -1;
    }
    compile(&parser);


    if (parser.errorCount > 0)
        printf("Program compiled with %d errors\n", parser.errorCount);
    else if (parser.errorCount == 0)
        printf("Program compiled successfully\n");

    parserDestroy(&parser);
    return 0;
}
gcc -E pmm build/lexer.o build/string.o build/parser.o build/main.o -I -Wall -Wextra -Wshadow -Wundef -Wformat=2 -Wfloat-equal -Wcast-align -std=c17 -march=native -O3 -Ofast -g -lm
